

token =
| keyword
| identifier 
| constant 
| string_literal 
| punctuator;

__pp_token_base =
| header_name
| identifier
| pp_number 
| character_constant
| string_literal;

preprocessing_token = __pp_token_base | punctuator;
#| each universal_character_name that cannot be one of the above 
#| each non_white_space character that cannot be one of the above

quote = "'";

keyword = "alignas" | "alignof" | "auto" | "bool"
| "break" | "case" | "char"
| "const" | "constexpr" | "continue"
| "default" | "do" | "double" | "else"
| "enum" | "extern" | "false" | "float" | "for"
| "goto" | "if"
| "inline" | "int" | "long" | "nullptr" | "register" | "restrict" | "return"
| "short" | "signed" | "sizeof" | "static"
| "static_assert" | "struct" | "switch"
| "thread_local" | "true"
| "typedef"
| "typeof"
| "typeof_unqual" | "union" | "unsigned"
| "void"
| "volatile" | "while"
| "_Atomic"
| "_BitInt"
| "_Complex"
| "_Decimal128"
| "_Decimal32"
| "_Decimal64"
| "_Generic"
| "_Imaginary"
| "_Noreturn";


identifier = identifier_start identifier_continue*;

identifier_start = nondigit;
#| XID_Start character
#| universal_character_name of class XID_Start

identifier_continue = digit | nondigit;
#| XID_Continue character
#| universal_character_name of class XID_Continue
 
nondigit = "[_a-zA-Z]";

digit = "[0-9]";

universal_character_name = "\\u" hex_quad | "\\U" hex_quad hex_quad;

hex_quad = "[0-9a-fA-F]{4}";

constant =
| integer_constant 
| floating_constant 
| enumeration_constant 
| character_constant 
| predefined_constant;

integer_constant = (decimal_constant | octal_constant | hexadecimal_constant | binary_constant) integer_suffix?;

decimal_constant = nonzero_digit {quote? digit};

octal_constant = "0" {quote? octal_digit};

hexadecimal_constant = hexadecimal_prefix hexadecimal_digit_sequence;

binary_constant =
| binary_prefix binary_digit 
| binary_constant quote? binary_digit;

hexadecimal_prefix = "0(x|X)";

binary_prefix = "0(b|B)";

nonzero_digit = "[1-9]";

octal_digit = "[0-7]";

hexadecimal_digit_sequence = hexadecimal_digit {quote? hexadecimal_digit};

hexadecimal_digit = "[0-9a-fA-F]";

binary_digit = "0|1";

integer_suffix =
| (unsigned_suffix long_suffix?)
| (unsigned_suffix long_long_suffix)
| (unsigned_suffix bit_precise_int_suffix)
| (long_suffix unsigned_suffix?)
| (long_long_suffix unsigned_suffix?)
| (bit_precise_int_suffix unsigned_suffix?);

bit_precise_int_suffix = "wb|WB";
unsigned_suffix = "u|U";
long_suffix = "l|L";
long_long_suffix = "ll|LL";

floating_constant = decimal_floating_constant | hexadecimal_floating_constant;

decimal_floating_constant =
| (fractional_constant exponent_part? floating_suffix?)  
| (digit_sequence exponent_part floating_suffix?);

hexadecimal_floating_constant = hexadecimal_prefix (hexadecimal_fractional_constant | hexadecimal_digit_sequence) binary_exponent_part floating_suffix?;

fractional_constant =
| (digit_sequence? "\." digit_sequence)
| (digit_sequence "\.");

exponent_part = "e|E" sign? digit_sequence;

sign = "\+|-";

digit_sequence = digit | (digit_sequence quote? digit);

hexadecimal_fractional_constant = hexadecimal_digit_sequence? "\." hexadecimal_digit_sequence;

binary_exponent_part = "p|P" sign? digit_sequence;

floating_suffix = "f|l|df|dd|dl|F|L|DF|DD|DL";

enumeration_constant = identifier;

character_constant = encoding_prefix? quote c_char_sequence quote;

encoding_prefix = "u8|u|U|L";

c_char_sequence = c_char*;

c_char = 
| "[^'\n\\]" # any member of the source character set except the single_quote ', backslash \, or new_line character
| escape_sequence; 

escape_sequence =
| simple_escape_sequence 
| octal_escape_sequence 
| hexadecimal_escape_sequence 
| universal_character_name;

simple_escape_sequence = "\\['\"\?\\abfnrtv]";

octal_escape_sequence = "\\" octal_digit octal_digit? octal_digit?;

hexadecimal_escape_sequence = "\\x" hexadecimal_digit hexadecimal_digit*;

predefined_constant = "false" | "true" | "nullptr";

string_literal = encoding_prefix? '"' s_char_sequence? '"';

s_char_sequence = s_char*;

s_char =
| "[^\"\n\\]" # any member of the source character set except the double_quote ", backslash \, or new_line character
| escape_sequence;

# `punctuator` minus things used later (e.g. "any pp-token other than ...")
__punctuator_base = "\." | "->"
| "\+\+" | "--" | "&" | "\*" | "\+" | "-" | "~" | "!"
| "/" | "%" | "==" | "!=" | "\^" | "\|" | "&&" | "\|\|" | "\?" | ":" | "::" | ";" | "\.\.\."
| "=" | "\*=" | "/=" | "%=" | "\+=" | "-=" | "&=" | "\^=" | "\|="
| "," | "#" | "##"
| "%:" | "%:%:";

__punctuator_angle_brackets = "<<" | ">>" | "<" | ">" | "<=" | ">=" | "<<=" | ">>=" | "<:" | ":>" | "<%" | "%>";
__punctuator_grouping = "\[" | "\]" | "\(" | "\)" | "\{" | "\}";

punctuator =  __punctuator_base | __punctuator_angle_brackets | __punctuator_grouping;

header_name =
| ("<" h_char_sequence ">")
| ('"' q_char_sequence '"');

h_char_sequence = h_char*;

# any member of the source character set except the new_line character and >
h_char = "[^\n>]";

q_char_sequence = q_char*;

# any member of the source character set except the new_line character and "
q_char = "[^\n\"]";

pp_number =
| (["\."] digit)
| (pp_number identifier_continue)
| (pp_number quote digit)
| (pp_number quote nondigit)
| (pp_number "e|E|p|P" sign)
| (pp_number "\.");

primary_expression =
| identifier
| constant
| string_literal
| ("\(" expression "\)")
| generic_selection;

generic_selection = "_Generic" "\(" assignment_expression "," generic_assoc_list "\)";

generic_assoc_list = generic_association {"," generic_association};


generic_association = (type_name | "default") ":" assignment_expression;

postfix_expression =
| primary_expression 
| (postfix_expression "\[" expression "\]")
| (postfix_expression "\(" argument_expression_list? "\)")
| (postfix_expression "\." identifier )
| (postfix_expression "->" identifier )
| (postfix_expression "\+\+")
| (postfix_expression "--")
| compound_literal;

argument_expression_list = assignment_expression {"," assignment_expression};

compound_literal = "\(" storage_class_specifiers? type_name "\)" braced_initializer;

storage_class_specifiers = storage_class_specifier*;

unary_expression =
| postfix_expression 
| ("\+\+" unary_expression)
| ("--" unary_expression)
| (unary_operator cast_expression)
| (sizeof unary_expression)
| (sizeof "\(" type_name "\)")
| (alignof "\(" type_name "\)");

unary_operator = "[&\*\+-~!]";

cast_expression = unary_expression | ("\(" type_name "\)" cast_expression);

multiplicative_expression =
| cast_expression
| (multiplicative_expression "\*" cast_expression) 
| (multiplicative_expression "/" cast_expression) 
| (multiplicative_expression "%" cast_expression);

additive_expression =
| multiplicative_expression 
| (additive_expression "\+" multiplicative_expression) 
| (additive_expression "-" multiplicative_expression);

shift_expression =
| additive_expression 
| (shift_expression "<<" additive_expression) 
| (shift_expression ">>" additive_expression);

relational_expression =
| shift_expression 
| (relational_expression "<" shift_expression) 
| (relational_expression ">" shift_expression) 
| (relational_expression "<=" shift_expression) 
| (relational_expression ">=" shift_expression);

equality_expression =
| relational_expression 
| (equality_expression "==" relational_expression) 
| (equality_expression "!=" relational_expression);

AND_expression = equality_expression {"&" equality_expression};

exclusive_OR_expression = AND_expression {"\^" AND_expression};

inclusive_OR_expression = exclusive_OR_expression {"\|" exclusive_OR_expression};

logical_AND_expression = inclusive_OR_expression {"&&" inclusive_OR_expression};

logical_OR_expression = logical_AND_expression {"\|\|" logical_AND_expression};

conditional_expression = logical_OR_expression ["\?" expression ":" conditional_expression];

assignment_expression =
| conditional_expression
| (unary_expression assignment_operator assignment_expression);

assignment_operator = "(\*|/|%|\+|-|<<|>>|&|\^|\|)?=";

expression =
| assignment_expression 
| (expression "," assignment_expression);

constant_expression = conditional_expression;

declaration =
| (declaration_specifiers init_declarator_list? ";")
| (attribute_specifier_sequence declaration_specifiers init_declarator_list ";")
| static_assert_declaration 
| attribute_declaration;

declaration_specifiers = declaration_specifier (attribute_specifier_sequence? | declaration_specifiers);

declaration_specifier =
| storage_class_specifier 
| type_specifier_qualifier 
| function_specifier;

init_declarator_list = init_declarator {"," init_declarator};

init_declarator = declarator declarator "=" initializer;

attribute_declaration = attribute_specifier_sequence ";";

storage_class_specifier =
| "auto" 
| "constexpr"
| "extern"
| "register"
| "static"
| "thread_local"
| "typedef";

type_specifier =
| "void"
| "char"
| "short"
| "int"
| "long" 
| "float"
| "double"
| "signed"
| "unsigned"
| ("_BitInt" "\(" constant_expression "\)")
| "bool"
| "_Complex"
| "_Decimal32"
| "_Decimal64"
| "_Decimal128"
| atomic_type_specifier 
| struct_or_union_specifier 
| enum_specifier 
| typedef_name 
| typeof_specifier;

struct_or_union_specifier =
| (struct_or_union attribute_specifier_sequence? identifier? "\{" member_declaration_list "\}")
| (struct_or_union attribute_specifier_sequence? identifier);

struct_or_union = "struct" | "union";

member_declaration_list = member_declaration*;

member_declaration =
| (attribute_specifier_sequence? specifier_qualifier_list member_declarator_list? ";")
| static_assert_declaration;

specifier_qualifier_list = type_specifier_qualifier (attribute_specifier_sequence? | specifier_qualifier_list); 

type_specifier_qualifier =
| type_specifier 
| type_qualifier 
| alignment_specifier;
  
member_declarator_list = member_declarator {"," member_declarator};

member_declarator =
| declarator
| (declarator? ":" constant_expression);

enum_specifier =
| (enum attribute_specifier_sequence? identifier? enum_type_specifier? "\{" enumerator_list [","] "\}")
| (enum identifier enum_type_specifier?);

enumerator_list = enumerator {"," enumerator};

enumerator = enumeration_constant attribute_specifier_sequence? ["=" constant_expression];

enum_type_specifier = ":" specifier_qualifier_list;

atomic_type_specifier = "_Atomic" "\(" type_name "\)";

typeof_specifier =
| ("typeof" "\(" typeof_specifier_argument "\)")
| ("typeof_unqual" "\(" typeof_specifier_argument "\)");

typeof_specifier_argument = expression | type_name;

type_qualifier = "const" | "restrict" | "volatile" | "_Atomic";

function_specifier = "inline" | "_Noreturn";

alignment_specifier = "alignas" "\(" (type_name | constant_expression) "\)";

declarator = pointer? direct_declarator;

direct_declarator =
| (identifier attribute_specifier_sequence? )
| ("\(" declarator "\)")
| (array_declarator attribute_specifier_sequence?)
| (function_declarator attribute_specifier_sequence?);

array_declarator =
| (direct_declarator "\[" type_qualifier_list? assignment_expression? "\]")
| (direct_declarator "\[" "static" type_qualifier_list? assignment_expression "\]")
| (direct_declarator "\[" type_qualifier_list "static" assignment_expression "\]" )
| (direct_declarator "\[" type_qualifier_list?  "\*" "\]");

function_declarator = direct_declarator "\(" parameter_type_list? "\)";

pointer = '\*' attribute_specifier_sequence? type_qualifier_list? pointer?;

type_qualifier_list = type_qualifier*;

parameter_type_list =
| parameter_list 
| (parameter_list "," "\.\.\.")
| "\.\.\.";

parameter_list = parameter_declaration {"," parameter_declaration};

parameter_declaration = attribute_specifier_sequence? declaration_specifiers (declarator | abstract_declarator?);

type_name = specifier_qualifier_list abstract_declarator?;

abstract_declarator = pointer | (pointer? direct_abstract_declarator);

direct_abstract_declarator =
| ("\(" abstract_declarator "\)")
| (array_abstract_declarator attribute_specifier_sequence?)
| (function_abstract_declarator attribute_specifier_sequence?);

array_abstract_declarator =
| (direct_abstract_declarator? "\[" type_qualifier_list? assignment_expression? "\]")
| (direct_abstract_declarator? "\[" static type_qualifier_list? assignment_expression "\]")
| (direct_abstract_declarator? "\[" type_qualifier_list static assignment_expression "\]") 
| (direct_abstract_declarator? "\[" "\*" "\]");

function_abstract_declarator = direct_abstract_declarator? "\(" parameter_type_list? "\)";

typedef_name = identifier;

braced_initializer = "\{" [initializer_list [","]] "\}";

initializer = assignment_expression | braced_initializer;

initializer_list = designation? initializer {"," designation? initializer};

designation = designator_list "=";

designator_list = designator*;

designator =
| ("\[" constant_expression "\]")
| ("." identifier);

static_assert_declaration = "static_assert" "\(" constant_expression ["," string_literal] "\)" ";";

attribute_specifier_sequence = attribute_specifier*;

attribute_specifier = "\[" "\[" attribute_list "\]" "\]";

attribute_list = attribute? {"," attribute?};

attribute = attribute_token attribute_argument_clause?;

attribute_token = standard_attribute | attribute_prefixed_token;

standard_attribute = identifier;

attribute_prefixed_token = attribute_prefix "::" identifier;

attribute_prefix = identifier;

attribute_argument_clause = "\(" balanced_token_sequence? "\)";

balanced_token_sequence = balanced_token*;

balanced_token =
| ("\(" balanced_token_sequence? "\)")
| ("\[" balanced_token_sequence? "\]")
| ("\{" balanced_token_sequence? "\}");
#| any token other than a parenthesis, a bracket, or a brace

statement = labeled_statement | unlabeled_statement;

unlabeled_statement =
| expression_statement 
| (attribute_specifier_sequence? primary_block) 
| (attribute_specifier_sequence? jump_statement);

primary_block =
| compound_statement 
| selection_statement 
| iteration_statement;

secondary_block = statement;

label = attribute_specifier_sequence? (identifier | ("case" constant_expression) | "default") ":";

labeled_statement = label statement;

compound_statement = "\{" block_item_list? "\}";

block_item_list = block_item*;

block_item = declaration | unlabeled_statement | label;

expression_statement = (expression? | (attribute_specifier_sequence expression)) ";";

selection_statement = 
| ("if" "\(" expression "\)" secondary_block) 
| ("if" "\(" expression "\)" secondary_block else secondary_block) 
| ("switch" "\(" expression "\)" secondary_block);

iteration_statement =
| ("while" "\(" expression "\)" secondary_block) 
| ("do" secondary_block "while" "\(" expression "\)" ";") 
| ("for" "\(" expression? ";" expression? ";" expression? "\)" secondary_block) 
| ("for" "\(" declaration expression? ";" expression? "\)" secondary_block);

jump_statement = (("goto" identifier) | "continue" | "break" | ("return" expression?)) ";";

translation_unit = external_declaration*;

external_declaration = function_definition | declaration;

function_definition = attribute_specifier_sequence? declaration_specifiers declarator function_body;

function_body = compound_statement;

preprocessing_file = group?;

group = group_part*;

group_part =
| if_section 
| control_line
| text_line 
| ("#" non_directive);

if_section = if_group elif_groups? else_group? endif_line;

if_group =
| ("#" "if" constant_expression new_line group?)
| ("#" "ifdef" identifier new_line group? "#" ifndef identifier new_line group?);

elif_groups = elif_group*;

elif_group =
| ("#" "elif" constant_expression new_line group?)
| ("#" "elifdef" identifier new_line group?)
| ("#" "elifndef" identifier new_line group?);

else_group = "#" "else" new_line group?;

endif_line = "#" "endif" new_line;

control_line = "#" [
| ("include" pp_tokens)
| ("embed" pp_tokens)
| ("define" identifier replacement_list)
| ("define" identifier lparen identifier_list? "\)" replacement_list)
| ("define" identifier lparen "\.\.\." "\)" replacement_list)
| ("define" identifier lparen identifier_list "," "\.\.\." "\)" replacement_list)
| ("undef" identifier)
| ("line" pp_tokens)
| ("error" pp_tokens?)
| ("warning" pp_tokens?)
| ("pragma" pp_tokens?)
] new_line;

text_line = pp_tokens? new_line;

non_directive = pp_tokens new_line;

# a ( character not immediately preceded by white space
# TODO: Actually do a look-behind
lparen = "\(";
  
replacement_list = pp_tokens?;

pp_tokens = preprocessing_token*;

# the new_line character
new_line = "\n";

identifier_list = identifier {"," identifier};

pp_parameter = pp_parameter_name pp_parameter_clause?;

pp_parameter_name = pp_standard_parameter | pp_prefixed_parameter;

pp_standard_parameter = identifier;

pp_prefixed_parameter = identifier "::" identifier;

pp_parameter_clause = "\(" pp_balanced_token_sequence? "\)";

pp_balanced_token_sequence = pp_balanced_token*;

pp_balanced_token =
| ("\(" pp_balanced_token_sequence? "\)")
| ("\[" pp_balanced_token_sequence? "\]")
| ("\{" pp_balanced_token_sequence? "\}")
| __pp_token_no_grouping;

# any pp_token other than a parenthesis, a bracket, or a brace
__pp_token_no_grouping =
| __pp_token_base
| __punctuator_base
| __punctuator_angle_brackets;

embed_parameter_sequence = pp_parameter*;

defined_macro_expression = "defined" (identifier | ("\(" identifier "\)"));

# any preprocessing_token other than >
h_preprocessing_token = 
| __pp_token_base
| __punctuator_base
| __punctuator_grouping;

h_pp_tokens = h_preprocessing_token*;

header_name_tokens = string_literal | ("<" h_pp_tokens ">");

has_include_expression = "__has_include" "\(" (header_name | header_name_tokens) "\)";

has_embed_expression =
| ("__has_embed" "\(" (header_name embed_parameter_sequence?) "\)")
| ("__has_embed" "\(" (header_name_tokens pp_balanced_token_sequence?) "\)");

has_c_attribute_express = "__has_c_attribute" "\(" pp_tokens "\)";

va_opt_replacement = "__VA_OPT__" "\(" pp_tokens? "\)";

standard_pragma = "#" "pragma" "STDC" (
| ("FP_CONTRACT" on_off_switch)
| ("FENV_ACCESS" on_off_switch)
| ("FENV_DEC_ROUND" dec_direction)
| ("FENV_ROUND" direction)
| ("CX_LIMITED_RANGE" on_off_switch)
);

on_off_switch = "ON" | "OFF" | "DEFAULT";

direction =
| "FE_DOWNWARD"
| "FE_TONEAREST"
| "FE_TONEARESTFROMZERO" 
| "FE_TOWARDZERO"
| "FE_UPWARD"
| "FE_DYNAMIC";

dec_direction =
| "FE_DEC_DOWNWARD"
| "FE_DEC_TONEAREST"
| "FE_DEC_TONEARESTFROMZERO" 
| "FE_DEC_TOWARDZERO"
| "FE_DEC_UPWARD"
| "FE_DEC_DYNAMIC";

n_char_sequence = {digit | nondigit};
n_wchar_sequence = {digit | nondigit};
d_char_sequence = {digit | nondigit};
d_wchar_sequence = {digit | nondigit};
