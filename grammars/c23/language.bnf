##include common.bnf

token =
| keyword
| identifier 
| constant 
| string_literal 
| punctuator;

keyword = "alignas" | "alignof" | "auto" | "bool"
| "break" | "case" | "char"
| "const" | "constexpr" | "continue"
| "default" | "do" | "double" | "else"
| "enum" | "extern" | "false" | "float" | "for"
| "goto" | "if"
| "inline" | "int" | "long" | "nullptr" | "register" | "restrict" | "return"
| "short" | "signed" | "sizeof" | "static"
| "static_assert" | "struct" | "switch"
| "thread_local" | "true"
| "typedef"
| "typeof"
| "typeof_unqual" | "union" | "unsigned"
| "void"
| "volatile" | "while"
| "_Atomic"
| "_BitInt"
| "_Complex"
| "_Decimal128"
| "_Decimal32"
| "_Decimal64"
| "_Generic"
| "_Imaginary"
| "_Noreturn";

##include identifier.bnf

universal_character_name = "\\u" hex_quad | "\\U" hex_quad hex_quad;

hex_quad = "[0-9a-fA-F]{4}";

constant =
| integer_constant 
| floating_constant 
| enumeration_constant 
| character_constant 
| predefined_constant;

integer_constant = (decimal_constant | octal_constant | hexadecimal_constant | binary_constant) integer_suffix?;

decimal_constant = nonzero_digit {quote? digit};

octal_constant = "0" {quote? octal_digit};

hexadecimal_constant = hexadecimal_prefix hexadecimal_digit_sequence;

binary_constant =
| binary_prefix binary_digit 
| binary_constant quote? binary_digit;

hexadecimal_prefix = "0(x|X)";

binary_prefix = "0(b|B)";

nonzero_digit = "[1-9]";

octal_digit = "[0-7]";

hexadecimal_digit_sequence = hexadecimal_digit {quote? hexadecimal_digit};

hexadecimal_digit = "[0-9a-fA-F]";

binary_digit = "0|1";

integer_suffix =
| (unsigned_suffix long_suffix?)
| (unsigned_suffix long_long_suffix)
| (unsigned_suffix bit_precise_int_suffix)
| (long_suffix unsigned_suffix?)
| (long_long_suffix unsigned_suffix?)
| (bit_precise_int_suffix unsigned_suffix?);

bit_precise_int_suffix = "wb|WB";
unsigned_suffix = "u|U";
long_suffix = "l|L";
long_long_suffix = "ll|LL";

floating_constant = decimal_floating_constant | hexadecimal_floating_constant;

decimal_floating_constant =
| (fractional_constant exponent_part? floating_suffix?)  
| (digit_sequence exponent_part floating_suffix?);

hexadecimal_floating_constant = hexadecimal_prefix (hexadecimal_fractional_constant | hexadecimal_digit_sequence) binary_exponent_part floating_suffix?;

fractional_constant =
| (digit_sequence? "\." digit_sequence)
| (digit_sequence "\.");

exponent_part = "e|E" sign? digit_sequence;

digit_sequence = digit | (digit_sequence quote? digit);

hexadecimal_fractional_constant = hexadecimal_digit_sequence? "\." hexadecimal_digit_sequence;

binary_exponent_part = "p|P" sign? digit_sequence;

floating_suffix = "f|l|df|dd|dl|F|L|DF|DD|DL";

enumeration_constant = identifier;

predefined_constant = "false" | "true" | "nullptr";

##include punctuator.bnf

primary_expression =
| identifier
| constant
| string_literal
| ("\(" expression "\)")
| generic_selection;

generic_selection = "_Generic" "\(" assignment_expression "," generic_assoc_list "\)";

generic_assoc_list = generic_association {"," generic_association};


generic_association = (type_name | "default") ":" assignment_expression;

postfix_expression =
| primary_expression 
| (postfix_expression "\[" expression "\]")
| (postfix_expression "\(" argument_expression_list? "\)")
| (postfix_expression "\." identifier )
| (postfix_expression "->" identifier )
| (postfix_expression "\+\+")
| (postfix_expression "--")
| compound_literal;

argument_expression_list = assignment_expression {"," assignment_expression};

compound_literal = "\(" storage_class_specifiers? type_name "\)" braced_initializer;

storage_class_specifiers = storage_class_specifier*;

unary_expression =
| postfix_expression 
| ("\+\+" unary_expression)
| ("--" unary_expression)
| (unary_operator cast_expression)
| (sizeof unary_expression)
| (sizeof "\(" type_name "\)")
| (alignof "\(" type_name "\)");

unary_operator = "[&\*\+-~!]";

cast_expression = unary_expression | ("\(" type_name "\)" cast_expression);

multiplicative_expression =
| cast_expression
| (multiplicative_expression "\*" cast_expression) 
| (multiplicative_expression "/" cast_expression) 
| (multiplicative_expression "%" cast_expression);

additive_expression =
| multiplicative_expression 
| (additive_expression "\+" multiplicative_expression) 
| (additive_expression "-" multiplicative_expression);

shift_expression =
| additive_expression 
| (shift_expression "<<" additive_expression) 
| (shift_expression ">>" additive_expression);

relational_expression =
| shift_expression 
| (relational_expression "<" shift_expression) 
| (relational_expression ">" shift_expression) 
| (relational_expression "<=" shift_expression) 
| (relational_expression ">=" shift_expression);

equality_expression =
| relational_expression 
| (equality_expression "==" relational_expression) 
| (equality_expression "!=" relational_expression);

AND_expression = equality_expression {"&" equality_expression};

exclusive_OR_expression = AND_expression {"\^" AND_expression};

inclusive_OR_expression = exclusive_OR_expression {"\|" exclusive_OR_expression};

logical_AND_expression = inclusive_OR_expression {"&&" inclusive_OR_expression};

logical_OR_expression = logical_AND_expression {"\|\|" logical_AND_expression};

conditional_expression = logical_OR_expression ["\?" expression ":" conditional_expression];

assignment_expression =
| conditional_expression
| (unary_expression assignment_operator assignment_expression);

assignment_operator = "(\*|/|%|\+|-|<<|>>|&|\^|\|)?=";

expression =
| assignment_expression 
| (expression "," assignment_expression);

constant_expression = conditional_expression;

declaration =
| (declaration_specifiers init_declarator_list? ";")
| (attribute_specifier_sequence declaration_specifiers init_declarator_list ";")
| static_assert_declaration 
| attribute_declaration;

declaration_specifiers = declaration_specifier (attribute_specifier_sequence? | declaration_specifiers);

declaration_specifier =
| storage_class_specifier 
| type_specifier_qualifier 
| function_specifier;

init_declarator_list = init_declarator {"," init_declarator};

init_declarator = declarator declarator "=" initializer;

attribute_declaration = attribute_specifier_sequence ";";

storage_class_specifier =
| "auto" 
| "constexpr"
| "extern"
| "register"
| "static"
| "thread_local"
| "typedef";

type_specifier =
| "void"
| "char"
| "short"
| "int"
| "long" 
| "float"
| "double"
| "signed"
| "unsigned"
| ("_BitInt" "\(" constant_expression "\)")
| "bool"
| "_Complex"
| "_Decimal32"
| "_Decimal64"
| "_Decimal128"
| atomic_type_specifier 
| struct_or_union_specifier 
| enum_specifier 
| typedef_name 
| typeof_specifier;

struct_or_union_specifier =
| (struct_or_union attribute_specifier_sequence? identifier? "\{" member_declaration_list "\}")
| (struct_or_union attribute_specifier_sequence? identifier);

struct_or_union = "struct" | "union";

member_declaration_list = member_declaration*;

member_declaration =
| (attribute_specifier_sequence? specifier_qualifier_list member_declarator_list? ";")
| static_assert_declaration;

specifier_qualifier_list = type_specifier_qualifier (attribute_specifier_sequence? | specifier_qualifier_list); 

type_specifier_qualifier =
| type_specifier 
| type_qualifier 
| alignment_specifier;
  
member_declarator_list = member_declarator {"," member_declarator};

member_declarator =
| declarator
| (declarator? ":" constant_expression);

enum_specifier =
| (enum attribute_specifier_sequence? identifier? enum_type_specifier? "\{" enumerator_list [","] "\}")
| (enum identifier enum_type_specifier?);

enumerator_list = enumerator {"," enumerator};

enumerator = enumeration_constant attribute_specifier_sequence? ["=" constant_expression];

enum_type_specifier = ":" specifier_qualifier_list;

atomic_type_specifier = "_Atomic" "\(" type_name "\)";

typeof_specifier =
| ("typeof" "\(" typeof_specifier_argument "\)")
| ("typeof_unqual" "\(" typeof_specifier_argument "\)");

typeof_specifier_argument = expression | type_name;

type_qualifier = "const" | "restrict" | "volatile" | "_Atomic";

function_specifier = "inline" | "_Noreturn";

alignment_specifier = "alignas" "\(" (type_name | constant_expression) "\)";

declarator = pointer? direct_declarator;

direct_declarator =
| (identifier attribute_specifier_sequence? )
| ("\(" declarator "\)")
| (array_declarator attribute_specifier_sequence?)
| (function_declarator attribute_specifier_sequence?);

array_declarator =
| (direct_declarator "\[" type_qualifier_list? assignment_expression? "\]")
| (direct_declarator "\[" "static" type_qualifier_list? assignment_expression "\]")
| (direct_declarator "\[" type_qualifier_list "static" assignment_expression "\]" )
| (direct_declarator "\[" type_qualifier_list?  "\*" "\]");

function_declarator = direct_declarator "\(" parameter_type_list? "\)";

pointer = '\*' attribute_specifier_sequence? type_qualifier_list? pointer?;

type_qualifier_list = type_qualifier*;

parameter_type_list =
| parameter_list 
| (parameter_list "," "\.\.\.")
| "\.\.\.";

parameter_list = parameter_declaration {"," parameter_declaration};

parameter_declaration = attribute_specifier_sequence? declaration_specifiers (declarator | abstract_declarator?);

type_name = specifier_qualifier_list abstract_declarator?;

abstract_declarator = pointer | (pointer? direct_abstract_declarator);

direct_abstract_declarator =
| ("\(" abstract_declarator "\)")
| (array_abstract_declarator attribute_specifier_sequence?)
| (function_abstract_declarator attribute_specifier_sequence?);

array_abstract_declarator =
| (direct_abstract_declarator? "\[" type_qualifier_list? assignment_expression? "\]")
| (direct_abstract_declarator? "\[" static type_qualifier_list? assignment_expression "\]")
| (direct_abstract_declarator? "\[" type_qualifier_list static assignment_expression "\]") 
| (direct_abstract_declarator? "\[" "\*" "\]");

function_abstract_declarator = direct_abstract_declarator? "\(" parameter_type_list? "\)";

typedef_name = identifier;

braced_initializer = "\{" [initializer_list [","]] "\}";

initializer = assignment_expression | braced_initializer;

initializer_list = designation? initializer {"," designation? initializer};

designation = designator_list "=";

designator_list = designator*;

designator =
| ("\[" constant_expression "\]")
| ("." identifier);

static_assert_declaration = "static_assert" "\(" constant_expression ["," string_literal] "\)" ";";

attribute_specifier_sequence = attribute_specifier*;

attribute_specifier = "\[" "\[" attribute_list "\]" "\]";

attribute_list = attribute? {"," attribute?};

attribute = attribute_token attribute_argument_clause?;

attribute_token = standard_attribute | attribute_prefixed_token;

standard_attribute = identifier;

attribute_prefixed_token = attribute_prefix "::" identifier;

attribute_prefix = identifier;

attribute_argument_clause = "\(" balanced_token_sequence? "\)";

balanced_token_sequence = balanced_token*;

balanced_token =
| ("\(" balanced_token_sequence? "\)")
| ("\[" balanced_token_sequence? "\]")
| ("\{" balanced_token_sequence? "\}");
#| any token other than a parenthesis, a bracket, or a brace

statement = labeled_statement | unlabeled_statement;

unlabeled_statement =
| expression_statement 
| (attribute_specifier_sequence? primary_block) 
| (attribute_specifier_sequence? jump_statement);

primary_block =
| compound_statement 
| selection_statement 
| iteration_statement;

secondary_block = statement;

label = attribute_specifier_sequence? (identifier | ("case" constant_expression) | "default") ":";

labeled_statement = label statement;

compound_statement = "\{" block_item_list? "\}";

block_item_list = block_item*;

block_item = declaration | unlabeled_statement | label;

expression_statement = (expression? | (attribute_specifier_sequence expression)) ";";

selection_statement = 
| ("if" "\(" expression "\)" secondary_block) 
| ("if" "\(" expression "\)" secondary_block else secondary_block) 
| ("switch" "\(" expression "\)" secondary_block);

iteration_statement =
| ("while" "\(" expression "\)" secondary_block) 
| ("do" secondary_block "while" "\(" expression "\)" ";") 
| ("for" "\(" expression? ";" expression? ";" expression? "\)" secondary_block) 
| ("for" "\(" declaration expression? ";" expression? "\)" secondary_block);

jump_statement = (("goto" identifier) | "continue" | "break" | ("return" expression?)) ";";

##root translation_unit
translation_unit = external_declaration;

external_declaration = function_definition | declaration;

function_definition = attribute_specifier_sequence? declaration_specifiers declarator function_body;

function_body = compound_statement;

n_char_sequence = {digit | nondigit};
n_wchar_sequence = {digit | nondigit};
d_char_sequence = {digit | nondigit};
d_wchar_sequence = {digit | nondigit};
